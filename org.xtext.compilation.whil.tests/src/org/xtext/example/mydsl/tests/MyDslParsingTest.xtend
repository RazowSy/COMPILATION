/*
 * generated by Xtext 2.10.0
 */
package org.xtext.example.mydsl.tests

import com.google.inject.Inject
import org.eclipse.xtext.junit4.InjectWith
import org.eclipse.xtext.junit4.XtextRunner
import org.eclipse.xtext.junit4.util.ParseHelper
import org.eclipse.xtext.junit4.validation.ValidationTestHelper
import org.junit.Assert
import org.junit.Test
import org.junit.runner.RunWith
import org.xtext.example.mydsl.myDsl.Program

@RunWith(XtextRunner)
@InjectWith(MyDslInjectorProvider)
class MyDslParsingTest{

	@Inject extension	ParseHelper<Program> 
     @Inject extension  ValidationTestHelper
	
	@Test 
	def void structureSimple() {
		('''
		function p :
		read X
		%
		nop
		% 
		write X
		''').parse.assertNoErrors
	}
	
	def void programSimple() {
		('''
		function p :
		read X
		%
		nop
		% 
		write X
		function d :
		read X
		%
		nop
		% 
		write X
		''').parse.assertNoErrors
	}
	
	@Test
	def void simplePlusieursRW() {
		('''
		function p :
		read X, Y
		% 
		nop;
		nop
		% 
		write X, Z
		''').parse.assertNoErrors
	}
		@Test
	def void affectationSimple() {
		('''
		function p :
		read X, Y, Z
		% 
		 X:= a;
		nop
		% 
		write X, Z
		''').parse.assertNoErrors
	}
		@Test
	def void affectationMultiple() {
		('''
		function p :
		read Ba, Cer
		% 
		X, Y := (cons a b) , (hd a);
		nop
		% 
		write AA, ZiA, Aa
		''').parse.assertNoErrors
	}
	
		@Test
	def void ifSimple() {
		('''
		function p :
		read B, C
		% 
		if a ?=b then 
		nop
		fi
		% 
		write A, Z
		''').parse.assertNoErrors
	}
	
	@Test
	def void whileSimple() {
		('''
		function p :
		read B, C
		% 
		while not a do 
		nop
		od
		% 
		write A, Z
		''').parse.assertNoErrors
	}
	
	@Test
	def void forSimple() {
		('''
		function p :
		read B, C
		% 
		for a do 
		nop
		od
		% 
		write A, Z
		''').parse.assertNoErrors
	}
	
	@Test
	def void foreachSimple() {
		('''
		function p :
		read B, C
		% 
		foreach a in nil do 
		nop
		od
		% 
		write A, Z
		''').parse.assertNoErrors
	}
	
	@Test
	def void whileComplexe() {
		('''
		function p :
		read B, C
		% 
		while a or b or (cons B a) do 
			while a ?= (hd b) do
			X, Y := (cons a b) , nil;
			nop
		od
		od
		% 
		write A, Z
		''').parse.assertNoErrors
	}
	@Test
	def void forComplexe() {
		('''
		function p :
		read B, C
		% 
		for a or b or (cons B a) do 
			for a ?= (hd b) do
			X, Y := (cons a b) , (hd a);
			nop
		od
		od
		% 
		write A, Z
		''').parse.assertNoErrors
	}
	@Test
	def void ifComplexe() {
		('''
		function p :
		read B, C
		% 
		if a and b or (cons B a) then
		if a ?= (hd b) then
		X, Y := (cons a b) , (hd a);
		nop
		fi
		fi
		% 
		write A, Z
		''').parse.assertNoErrors
	}
	@Test
	def void functionComplexe() {
		('''
		function p :
		read B, C
		% 
		for a or b or (cons B a) do 
		X := (cons a (cons B (hd C)));
			while a ?= (hd b) do
			if C then 
			X, Y := (cons a b) , (hd a);
			nop
			fi
		od
		od
		% 
		write A, Z
		''').parse.assertNoErrors
	}
	
	// Test faux
	@Test
	def void structureFalse() {
		val x=('''
		function p :
		read z
		%
		nop
		% 
		write X
		''').parse.validate.empty
		Assert.assertFalse("z minuscule", x)
	}
	@Test
	def void affectationFalse() {
		val x=('''
		function p :
		read Z
		%
		X:= (cons a b), Z
		% 
		write X
		''').parse.validate.empty
		Assert.assertFalse( x)
	}
	@Test
	def void pointVirguleManquant() {
		val x=('''
		function p :
		read Z
		%
		X, Y:= (a b), (cons a nil)
		nop
		% 
		write X
		''').parse.validate.empty
		Assert.assertFalse( x)
	}
	@Test
	def void pourcentManquant() {
		val x=('''
		function p :
		read Z
		nop;
		nop
		% 
		write X
		''').parse.validate.empty
		Assert.assertFalse( x)
	}
	@Test
	def void deuxpointManquant() {
		val x=('''
		function p 
		read Z
		%
		nop;
		nop
		% 
		write X
		''').parse.validate.empty
		Assert.assertFalse( x)
	}
	@Test
	def void fiManquant() {
		val x=('''
		function p :
		read Z
		%
		if a then
		nop
		% 
		write X
		''').parse.validate.empty
		Assert.assertFalse( x)
	}
	@Test
	def void odManquant() {
		val x=('''
		function p :
		read Z
		%
		while a do
		nop
		% 
		write X
		''').parse.validate.empty
		Assert.assertFalse( x)
	}
	@Test
	def void inputVirgule() {
		val x=('''
		function p :
		read Z A
		%
		while a do
		nop
		% 
		write X
		''').parse.validate.empty
		Assert.assertFalse( x)
	}
	
	@Test
	def void inputMAJ() {
		val x=('''
		function p :
		read a , B
		%
		while a do
		nop
		% 
		write X
		''').parse.validate.empty
		Assert.assertFalse( x)
	}
	
		
	@Test
	def void outputMAJ() {
		val x=('''
		function p :
		read Aze , Bze
		%
		while a do
		nop
		% 
		write a , Z
		''').parse.validate.empty
		Assert.assertFalse( x)
	}
	
	@Test
	def void outputVirgule() {
		val x=('''
		function p :
		read Z, A
		%
		while a do
		nop
		% 
		write X A
		''').parse.validate.empty
		Assert.assertFalse( x)
	}
	
	@Test
	def void ABinMaltype() {
		val x=('''
		function p :
		read Z
		%
		X:= cons a b)
		% 
		write X
		''').parse.validate.empty
		Assert.assertFalse( x)
	}
	@Test
	def void ABinMaltype2() {
		val x=('''
		function p :
		read Z
		%
		X:= (cons a )
		% 
		write X
		''').parse.validate.empty
		Assert.assertFalse( x)
	}
	@Test
	def void ABinMaltype3() {
		val x=('''
		function p :
		read Z
		%
		X:= (hd  )
		% 
		write X
		''').parse.validate.empty
		Assert.assertFalse( x)
	}
	@Test
	def void ABinMaltype4() {
		val x=('''
		function p :
		read Z
		%
		X:= (tl  )
		% 
		write X
		''').parse.validate.empty
		Assert.assertFalse( x)
	}
	
	@Test
	def void condMissing() {
		val x=('''
		function p :
		read Z
		%
		if a b then
		nop
		fi
		% 
		write X
		''').parse.validate.empty
		Assert.assertFalse( x)
	}
	}

